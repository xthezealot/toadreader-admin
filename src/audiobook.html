<script>
    const token = localStorage.getItem("token")

    Alpine.data("audiobook", () => ({
        id: null,
        title: "",
        author: null,
        existentCover: null,
        coverFile: null,
        chapters: [],
        isSaving: false,


        async init() {
            await this.loadAudiobook()
        },


        async loadAudiobook() {
            try {
                const paramsStr = location.hash.includes("?") ? location.hash.split("?")[1] : ""
                const params = new URLSearchParams(paramsStr)
                const idStr = params.get("id")

                // no id provided: treat as new audiobook (skip fetch)
                if (!idStr) return

                // fetch audiobook
                const response = await fetch(`http://localhost:4567/audiobooks/${idStr}`, {
                    headers: { Authorization: `Bearer ${token}` }
                })

                if (response.ok) {
                    const audiobook = await response.json()
                    this.id = audiobook.id
                    this.title = audiobook.title
                    this.author = audiobook.author
                    this.existentCover = audiobook.cover
                    this.chapters = this.normalizeChapters(audiobook.chapters)
                } else {
                    console.error("Failed to load audiobook")
                }
            } catch (error) {
                console.error("Network error:", error)
            }
        },


        generateChapterKey() {
            return `ch-${Math.random().toString(36).slice(2, 10)}`
        },


        normalizeChapters(list) {
            if (!Array.isArray(list)) return []
            return list.map(chapter => {
                const normalized = { ...(chapter || {}) }
                normalized.oldFile = chapter?.file ?? chapter?.oldFile ?? null
                delete normalized.file
                normalized.children = this.normalizeChapters(chapter.children)
                normalized._key = chapter?.id != null ? `id-${chapter.id}` : (chapter?._key || this.generateChapterKey())
                normalized.newFile = chapter?.newFile ?? null
                normalized.newFileUrl = chapter?.newFileUrl ?? null
                return normalized
            })
        },


        createEmptyChapter(title = "New chapter") {
            return {
                title,
                oldFile: null,
                children: [],
                _key: this.generateChapterKey(),
                newFile: null,
                newFileUrl: null
            }
        },


        titleFromFile(file) {
            if (!file?.name) return "New chapter"
            const dotIndex = file.name.lastIndexOf(".")
            if (dotIndex > 0) return file.name.slice(0, dotIndex)
            return file.name
        },


        addChaptersFromFiles(fileList) {
            if (!fileList || !fileList.length) return
            Array.from(fileList).forEach(file => {
                if (!file) return
                if (file.type && !file.type.startsWith("audio/")) return
                const chapter = this.createEmptyChapter(this.titleFromFile(file))
                chapter.newFile = file
                chapter.newFileUrl = URL.createObjectURL(file)
                this.chapters.push(chapter)
            })
        },


        handleChapterFiles(input) {
            if (!input) return
            this.addChaptersFromFiles(input.files)
            input.value = ""
        },


        serializeChapters(root, formData, index = null) {
            if (!root) return []
            const chapterIndex = index || this.buildChapterIndex()
            const items = Array.from(root.children).filter(el => el.tagName === "LI")
            return items.map(item => {
                let key = item.dataset.chapterKey || null
                if (!key) {
                    key = this.generateChapterKey()
                    item.dataset.chapterKey = key
                }
                const chapterRef = chapterIndex.get(item.dataset.chapterKey) || null
                const chapter = {}
                const titleInput = item.querySelector('input[name="title"]')
                chapter.title = titleInput ? titleInput.value : ""
                const newFileInput = item.querySelector('input[name="newFile"]')
                const oldFileInput = item.querySelector('input[name="oldFile"]')
                const storedFile = chapterRef?.newFile || null
                const file = newFileInput?.files?.[0] || storedFile || null
                if (chapterRef && file) chapterRef.newFile = file
                if (file) {
                    const ext = file.name.includes('.') ? `.${file.name.split('.').pop()}` : ""
                    const filename = `${this.generateChapterKey()}${ext}`
                    formData.set(filename, file)
                    chapter.file = filename
                } else if (oldFileInput?.value || chapterRef?.oldFile) {
                    chapter.file = oldFileInput?.value || chapterRef?.oldFile
                }
                const childList = Array.from(item.children).find(el => el.tagName === "UL") || null
                const children = this.serializeChapters(childList, formData, chapterIndex)
                if (children.length) chapter.children = children
                return chapter
            })
        },


        removeChapter(list, chapter) {
            if (!Array.isArray(list)) return
            const index = list.findIndex(item => item._key === chapter?._key)
            if (index === -1) return
            const [removed] = list.splice(index, 1)
            if (removed?.newFileUrl) URL.revokeObjectURL(removed.newFileUrl)
            if (removed) {
                removed.newFile = null
                removed.newFileUrl = null
            }
        },


        buildChapterIndex(list = this.chapters, map = new Map()) {
            if (!Array.isArray(list)) return map
            list.forEach(chapter => {
                if (!chapter || typeof chapter !== "object") return
                if (chapter._key) map.set(chapter._key, chapter)
                this.buildChapterIndex(chapter.children, map)
            })
            return map
        },


        applyChapterOrder(target, source) {
            if (!Array.isArray(target)) return
            target.splice(0, target.length, ...(Array.isArray(source) ? source : []))
        },


        collectChaptersFromDom(listEl, index) {
            if (!listEl) return []
            const items = Array.from(listEl.children).filter(el => el.tagName === "LI")
            return items.map(item => {
                let key = item.dataset.chapterKey || null
                if (!key) {
                    key = this.generateChapterKey()
                    item.dataset.chapterKey = key
                }
                let chapter = index.get(key)
                if (!chapter) {
                    chapter = this.createEmptyChapter()
                    chapter._key = key
                    index.set(key, chapter)
                }
                chapter._key = key
                const titleInput = item.querySelector('input[name="title"]')
                if (titleInput) chapter.title = titleInput.value
                const oldFileInput = item.querySelector('input[name="oldFile"]')
                chapter.oldFile = oldFileInput?.value || null
                const childList = Array.from(item.children).find(el => el.tagName === "UL") || null
                const orderedChildren = this.collectChaptersFromDom(childList, index)
                if (!Array.isArray(chapter.children)) chapter.children = []
                this.applyChapterOrder(chapter.children, orderedChildren)
                return chapter
            })
        },


        syncChaptersFromDom(event) {
            try {
                if (event?.target) {
                    const chaptersRoot = this.$el.querySelector("#chapters")
                    if (!chaptersRoot || !chaptersRoot.contains(event.target)) return
                }
                const rootList = this.$el.querySelector("#chapters > ul")
                if (!rootList) return
                const index = this.buildChapterIndex()
                const ordered = this.collectChaptersFromDom(rootList, index)
                this.applyChapterOrder(this.chapters, ordered)
            } catch (error) {
                console.error("Failed to sync chapters", error)
            }
        },


        get coverUrl() {
            if (this.coverFile) return URL.createObjectURL(this.coverFile)
            return this.existentCover ? `http://localhost:4567/storage/${this.existentCover}` : null
        },


        async saveAudiobook(event) {
            if (this.isSaving) return
            this.isSaving = true
            try {
                const formData = new FormData()
                formData.set("title", this.title ?? "")
                formData.set("author", this.author ?? "")
                // cover
                if (this.coverFile) formData.set("cover", this.coverFile)
                else if (this.existentCover) formData.set("cover", this.existentCover)
                else formData.set("cover", null)
                // chapters
                const chaptersRoot = this.$el.querySelector("#chapters > ul")
                const chapters = this.serializeChapters(chaptersRoot, formData)
                formData.set("chapters", JSON.stringify(chapters))

                const response = await fetch(`http://localhost:4567/audiobooks${this.id ? `/${this.id}` : ""}`, {
                    method: this.id ? "PUT" : "POST",
                    headers: { Authorization: `Bearer ${token}` },
                    body: formData,
                })

                if (response.ok) {
                    console.log("Audiobook saved successfully")
                    location.hash = "audiobooks.html"
                } else {
                    console.error("Failed to save audiobook", response)
                    this.isSaving = false
                }
            } catch (error) {
                console.error("Network error:", error)
                this.isSaving = false
            }
        },
    }))
</script>


<style>
    #audiobook {
        .form-grid {
            display: grid;
            gap: 1.5rem;

            @media (min-width: 768px) {
                grid-template-columns: minmax(200px, 1fr) 2fr;
                align-items: start;
            }
        }

        .cover-card {
            display: grid;
            gap: 1rem;
            justify-items: start;

            .cover-frame {
                position: relative;
            }
        }

        .cover-preview {
            max-width: 220px;
            width: 100%;
            border-radius: 1rem;
            box-shadow: 0 0 1em rgba(0, 0, 0, 0.1);
        }

        .cover-placeholder {
            width: 220px;
            aspect-ratio: 3 / 4;
            border-radius: 1rem;
            border: 1px dashed #ced4da;
            display: grid;
            place-items: center;
            color: #adb5bd;
            text-transform: uppercase;
            letter-spacing: .08em;
            font-weight: 600;
            background: #fff;
        }

        .file-upload-button {
            position: relative;
            display: inline-flex;
            align-items: center;
            justify-content: center;

            input[type="file"] {
                position: absolute;
                inset: 0;
                opacity: 0;
                cursor: pointer;
            }
        }

        .meta {
            display: grid;
            gap: 1rem;
        }

        #chapters {
            display: grid;
            gap: 1rem;

            .chapter-actions {
                display: flex;
                flex-wrap: wrap;
                gap: .75rem;
            }

            ul {
                list-style: none;
                padding-bottom: 1rem;
                padding-left: 1rem;

                li {
                    cursor: move;
                    background: rgba(52, 58, 64, .05);
                    border-radius: .5rem;
                    padding: .75rem 1rem;

                    & + li {
                        margin-top: .5rem;
                    }

                    & > div {
                        display: grid;
                        gap: .5rem;
                        margin-bottom: .75rem;
                    }

                    input[type="text"],
                    input[type="file"],
                    audio {
                        width: 100%;
                    }
                }
            }

            & > ul {
                padding-left: 0;
            }
        }

        .danger {
            background: #c92a2a;
            color: #fff;

            &:hover {
                background: #a51122;
            }
        }

        .form-actions {
            display: flex;
            justify-content: flex-end;
        }

        .loading-state {
            display: grid;
            place-items: center;
            min-height: 8rem;
            max-width: 960px;
            padding: 1.5rem;
            border-radius: 1rem;
            border: 1px solid #a5d8ff;
            background: #e7f5ff;
            color: #339af0;
            font-weight: 500;
        }
    }
</style>


<div id="audiobook" x-data="audiobook" @end.window="syncChaptersFromDom($event)">
    <dashboard-shell :title="title">
        <form @submit.prevent="saveAudiobook" class="form-stacked" x-show="!isSaving">
            <section>
                <h2>Details</h2>
                <div class="form-grid">
                    <div class="cover-card">
                        <div class="cover-frame">
                            <template x-if="coverUrl">
                                <img class="cover-preview" :src="coverUrl" />
                            </template>
                            <template x-if="!coverFile && !existentCover">
                                <div class="cover-placeholder">No cover</div>
                            </template>
                        </div>
                        <label class="button file-upload-button">
                            <span x-text="coverFile || existentCover ? 'Change cover' : 'Upload cover'"></span>
                            <input type="file" name="cover" @change="coverFile = $event.target.files[0]" accept="image/*">
                        </label>
                    </div>
                    <div class="meta">
                        <div class="field">
                            <span>Title</span>
                            <input type="text" name="title" x-model="title" placeholder="Title" required>
                        </div>
                        <div class="field">
                            <span>Author</span>
                            <input type="text" name="author" x-model="author" placeholder="Author">
                        </div>
                    </div>
                </div>
            </section>

            <section id="chapters">
                <h2>Chapters</h2>
                <div class="chapter-actions">
                    <button type="button" @click="chapters.push(createEmptyChapter())">Add chapter</button>
                    <label class="button file-upload-button">
                        Add chapters from files
                        <input type="file" multiple accept="audio/*" @change="handleChapterFiles($event.target)">
                    </label>
                </div>
                <ul x-sort="chapters" group="chapters" x-sort:group="chapters">
                    <template x-for="chapterL1 in chapters" :key="chapterL1._key">
                        <li x-sort:item="chapterL1" :data-chapter-key="chapterL1._key">
                            <div x-data="{
                                chapter: chapterL1,
                                audioPreview: null,
                                init() {
                                    this.audioPreview = this.computePreview()
                                },
                                computePreview() {
                                    if (this.chapter?.newFileUrl) return this.chapter.newFileUrl
                                    if (this.chapter?.oldFile) return 'http://localhost:4567/storage/' + this.chapter.oldFile
                                    return null
                                },
                                setNewFile(file) {
                                    if (this.chapter?.newFileUrl) {
                                        URL.revokeObjectURL(this.chapter.newFileUrl)
                                        this.chapter.newFileUrl = null
                                    }
                                    this.chapter.newFile = file
                                    if (file) this.chapter.newFileUrl = URL.createObjectURL(file)
                                    this.audioPreview = this.computePreview()
                                }
                            }">
                                <input type="text" name="title" x-model="chapter.title">
                                <input type="hidden" name="oldFile" x-model="chapter.oldFile">
                                <input type="file" name="newFile" @change="setNewFile($event.target.files[0] || null)">
                                <audio controls x-show="audioPreview" :src="audioPreview"></audio>
                            </div>
                            <button type="button" class="danger" @click="removeChapter(chapters, chapterL1)">Delete</button>
                            <ul x-sort="chapterL1.children" group="chapters" x-sort:group="chapters">
                                <template x-for="chapterL2 in chapterL1.children" :key="chapterL2._key">
                                    <li x-sort:item="chapterL2" :data-chapter-key="chapterL2._key">
                                        <div x-data="{
                                            chapter: chapterL2,
                                            audioPreview: null,
                                            init() {
                                                this.audioPreview = this.computePreview()
                                            },
                                            computePreview() {
                                                if (this.chapter?.newFileUrl) return this.chapter.newFileUrl
                                                if (this.chapter?.oldFile) return 'http://localhost:4567/storage/' + this.chapter.oldFile
                                                return null
                                            },
                                            setNewFile(file) {
                                                if (this.chapter?.newFileUrl) {
                                                    URL.revokeObjectURL(this.chapter.newFileUrl)
                                                    this.chapter.newFileUrl = null
                                                }
                                                this.chapter.newFile = file
                                                if (file) this.chapter.newFileUrl = URL.createObjectURL(file)
                                                this.audioPreview = this.computePreview()
                                            }
                                        }">
                                            <input type="text" name="title" x-model="chapter.title">
                                            <input type="hidden" name="oldFile" x-model="chapter.oldFile">
                                            <input type="file" name="newFile" @change="setNewFile($event.target.files[0] || null)">
                                            <audio controls x-show="audioPreview" :src="audioPreview"></audio>
                                        </div>
                                        <button type="button" class="danger" @click="removeChapter(chapterL1.children, chapterL2)">Delete</button>
                                        <ul x-sort="chapterL2.children" group="chapters" x-sort:group="chapters">
                                            <template x-for="chapterL3 in chapterL2.children" :key="chapterL3._key">
                                                <li x-sort:item="chapterL3" :data-chapter-key="chapterL3._key">
                                                    <div x-data="{
                                                        chapter: chapterL3,
                                                        audioPreview: null,
                                                        init() {
                                                            this.audioPreview = this.computePreview()
                                                        },
                                                        computePreview() {
                                                            if (this.chapter?.newFileUrl) return this.chapter.newFileUrl
                                                            if (this.chapter?.oldFile) return 'http://localhost:4567/storage/' + this.chapter.oldFile
                                                            return null
                                                        },
                                                        setNewFile(file) {
                                                            if (this.chapter?.newFileUrl) {
                                                                URL.revokeObjectURL(this.chapter.newFileUrl)
                                                                this.chapter.newFileUrl = null
                                                            }
                                                            this.chapter.newFile = file
                                                            if (file) this.chapter.newFileUrl = URL.createObjectURL(file)
                                                            this.audioPreview = this.computePreview()
                                                        }
                                                    }">
                                                        <input type="text" name="title" x-model="chapter.title">
                                                        <input type="hidden" name="oldFile" x-model="chapter.oldFile">
                                                        <input type="file" name="newFile" @change="setNewFile($event.target.files[0] || null)">
                                                        <audio controls x-show="audioPreview" :src="audioPreview"></audio>
                                                    </div>
                                                    <button type="button" class="danger" @click="removeChapter(chapterL2.children, chapterL3)">Delete</button>
                                                </li>
                                            </template>
                                        </ul>
                                    </li>
                                </template>
                            </ul>
                        </li>
                    </template>
                </ul>
            </section>

            <div class="form-actions">
                <button type="submit">Save</button>
            </div>
        </form>
        <template x-if="isSaving">
            <div class="loading-state">
                Uploading audiobook...
            </div>
        </template>
    </dashboard-shell>
</div>
