<script>
    const token = localStorage.getItem("token")

    Alpine.data("audiobook", () => ({
        id: null,
        title: "",
        author: null,
        existentCover: null,
        coverFile: null,
        chapters: [
            {
                title: "One",
                children: [
                    {
                        title: "Two",
                        children: [
                            {
                                title: "Three",
                                file: "hello.weba"
                            }
                        ]
                    }
                ]
            },
            {
                title: "Four",
                children: [
                    {
                        title: "Five",
                        children: [
                            {
                                title: "Six",
                            }
                        ]
                    }
                ]
            },
            {
                title: "Seven",
            }
        ],


        async init() {
            await this.loadAudiobook()
            this.ensureChapterCids(this.chapters)
            this.$nextTick(() => this.makeChaptersSortable())
        },


        async loadAudiobook() {
            try {
                const paramsStr = location.hash.includes("?") ? location.hash.split("?")[1] : ""
                const params = new URLSearchParams(paramsStr)
                const idStr = params.get("id")

                // no id provided: treat as new audiobook (skip fetch)
                if (!idStr) return

                // fetch audiobook
                const response = await fetch(`http://localhost:4567/audiobooks/${idStr}`, {
                    headers: { Authorization: `Bearer ${token}` }
                })

                if (response.ok) {
                    const audiobook = await response.json()
                    this.id = audiobook.id
                    this.title = audiobook.title
                    this.author = audiobook.author
                    this.existentCover = audiobook.cover
                    this.chapters = audiobook.chapters
                } else {
                    console.error("Failed to load audiobook")
                }
            } catch (error) {
                console.error("Network error:", error)
            }
        },


        get coverUrl() {
            if (this.coverFile) return URL.createObjectURL(this.coverFile)
            return this.existentCover ? `http://localhost:4567/storage/${this.existentCover}` : null
        },


        renderChapters(chapters) {
            let html = "<ul>"
            chapters?.map(chapter => {
                const childrenHtml = this.renderChapters(chapter.children)
                // file: string | File
                html += `<li data-cid="${chapter._cid}">
                    <div class="chapter">
                        <p>Title: <input type="text" name="title" value="${chapter.title}" required></p>
                        <p>Current file: <input name="oldFile" type="text" value="${typeof chapter.file === "string" ? chapter.file : ""}" readonly></p>
                        <p>New file: <input name="newFile" type="file"></p>
                    </div>
                    ${childrenHtml}
                </li>`
            })
            html += "</ul>"
            return html
        },


        makeChaptersSortable() {
            const uls = document.querySelectorAll("#chapters ul")
            uls.forEach(ul => {
                Sortable.create(ul, {
                    group: "chapters",
                    animation: 150,
                    fallbackOnBody: true,
                    swapThreshold: 0.65,
                    onEnd: () => this.setChaptersFromDom()
                })
            })
        },


        setChaptersFromDom() {
            // preserve previous chapter state (including File objects) by mapping by client id
            const prevByCid = new Map()
            const collect = arr => arr?.forEach(ch => { prevByCid.set(ch._cid, ch); collect(ch.children || []) })
            collect(this.chapters || [])

            // update chapters order in this.chapters based on the dom
            const parse = ul => [...ul.children].map(li => {
                const cid = li.dataset.cid
                const prev = prevByCid.get(cid)
                const newFile = li.querySelector("input[name='newFile']").files[0]
                return {
                    _cid: cid,
                    title: li.querySelector("input[name='title']").value.trim(),
                    file: newFile || prev?.file || li.querySelector("input[name='oldFile']").value || undefined,
                    children: li.children[1] ? parse(li.children[1]) : []
                }
            })
            this.chapters = parse(document.querySelector("#chapters ul"))

            // reinitialize sortability after alpine re-renders chapters
            this.$nextTick(() => this.makeChaptersSortable())
        },


        // ensure stable client ids so we can preserve state across re-renders
        ensureChapterCids(chapters) {
            const walk = arr => arr?.forEach(ch => {
                if (!ch._cid) ch._cid = crypto.randomUUID()
                if (!Array.isArray(ch.children)) ch.children = []
                walk(ch.children)
            })
            walk(chapters)
        },


        addChapter() {
            this.chapters.push({ _cid: crypto.randomUUID(), title: "New chapter", file: null, children: [] })
            this.$nextTick(() => this.makeChaptersSortable())
        },


        async saveAudiobook(event) {
            try {
                const formData = new FormData(event.target)
                // cover
                if (this.coverFile) formData.set("cover", this.coverFile)
                else if (this.existentCover) formData.set("cover", this.existentCover)
                else formData.set("cover", null)
                // chapters
                formData.append("chapters", JSON.stringify(this.chapters))

                const response = await fetch(`http://localhost:4567/audiobooks${this.id ? `/${this.id}` : ""}`, {
                    method: this.id ? "PUT" : "POST",
                    headers: { Authorization: `Bearer ${token}` },
                    body: formData,
                })

                if (response.ok) {
                    console.log("Audiobook saved successfully")
                    location.hash = "audiobooks.html"
                } else {
                    console.error("Failed to save audiobook", response)
                }
            } catch (error) {
                console.error("Network error:", error)
            }
        },
    }))
</script>


<style>
    .cover-preview {
        max-width: 300px;
        max-height: 300px;
        box-shadow: 0 0 1em rgba(0, 0, 0, 0.1);
        border-radius: 1rem;
    }

    /* Chapter lists styling */
    #chapters {
        ul {
            list-style: none;
            padding-bottom: 1rem;
            padding-left: 1rem;

            li {
                cursor: move;
                background: rgba(52, 58, 64, .05);
                border-radius: .5rem;
                padding: .5rem 1rem;

                & + li {
                    margin-top: .5rem;
                }

                & > div {
                    margin-bottom: .5rem;
                }
            }
        }

        & > div > ul {
            padding-left: 0;
        }
    }
</style>


<div x-data="audiobook" @setChaptersFromDom.window="setChaptersFromDom">
    <dashboard-shell :title="title">
        <form @submit.prevent="saveAudiobook">
            <!-- cover -->
            <template x-if="coverUrl">
                <img class="cover-preview" :src="coverUrl" />
            </template>

            <div>
                <input type="file" name="cover" @change="coverFile = $event.target.files[0]" accept="image/*">
            </div>

            <!-- title and author -->
            <div>
                <input type="text" name="title" x-model="title" placeholder="Title" required></input>
            </div>
            <div>
                <input type="text" name="author" x-model="author" placeholder="Author"></input>
            </div>

            <div id="chapters">
                <h2 class="title">Chapters</h2>
                <div style="margin: .5rem 0">
                    <button type="button" @click="addChapter">Add chapter</button>
                </div>
                <div x-html="renderChapters(chapters)" @change="setChaptersFromDom"></div>
            </div>

            <pre x-text="JSON.stringify(chapters, null, 2)"></pre>

            <button type="submit">Save</button>
        </form>
    </dashboard-shell>
</div>
